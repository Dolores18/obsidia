1. 结构体包含引用
```
// 必须标注，因为结构体包含引用字段
struct Cache<'a> {
    data: &'a [u8],         // 引用字段
    metadata: &'a str,      // 引用字段
}

// 实现方法时也需要标注
impl<'a> Cache<'a> {
    fn get_data(&self) -> &'a [u8] {
        self.data
    }
}
```
2. 多个引用参数的函数
   ```
   // 必须标注，因为有多个引用参数
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// 不同生命周期的情况
fn different_lifetimes<'a, 'b>(x: &'a str, y: &'b str) -> String {
    format!("{}{}", x, y)
}
   ```


3. 返回引用的函数


```

// 必须标注，因为返回引用
fn get_first<'a>(data: &'a Vec<String>) -> &'a String {
    &data[0]
}

// 返回引用的泛型函数
fn first_item<'a, T>(list: &'a [T]) -> &'a T {
    &list[0]
}
```


4. 泛型结构体中的引用
```
// 必须标注，因为结构体是泛型且包含引用
struct Wrapper<'a, T> {
    value: &'a T,
    count: usize,
}

impl<'a, T> Wrapper<'a, T> {
    fn new(value: &'a T) -> Self {
        Wrapper {
            value,
            count: 0,
        }
    }
}
```

5. trait 中的生命周期
```

// trait 定义中包含引用
trait Parser<'a> {
    fn parse(&self, input: &'a str) -> Result<&'a str, &'a str>;
}

// 实现带生命周期的 trait
impl<'a> Parser<'a> for MyParser {
    fn parse(&self, input: &'a str) -> Result<&'a str, &'a str> {
        // 解析逻辑
        Ok(&input[1..])
    }
}
```

6. 迭代器实现

```
// 自定义迭代器必须标注生命周期
struct IterWrapper<'a, T> {
    slice: &'a [T],
    index: usize,
}

impl<'a, T> Iterator for IterWrapper<'a, T> {
    type Item = &'a T;
    
    fn next(&mut self) -> Option<Self::Item> {
        let item = self.slice.get(self.index)?;
        self.index += 1;
        Some(item)
    }
}
```

7. 复杂数据结构
```
// 多层引用的数据结构
struct Node<'a> {
    parent: Option<&'a Node<'a>>,
    children: Vec<Node<'a>>,
    data: &'a str,
}

impl<'a> Node<'a> {
    fn add_child(&mut self, data: &'a str) {
        self.children.push(Node {
            parent: Some(self),
            children: Vec::new(),
            data,
        });
    }
}

```
8. 生命周期约束


```
// 带有生命周期约束的泛型
struct Database<'a, T: 'a> {
    connection: &'a Connection,
    cache: Vec<&'a T>,
}

// 多重生命周期约束
fn complex_operation<'a, 'b: 'a>(
    data: &'a str,
    context: &'b Context,
) -> &'a str {
    // 操作逻辑
    data
}
```






