const KEY_LEN: usize = Inner::KeySize::USIZE;
const IV_LEN: usize = SALT_LEN;
const PRE_CHUNK_OVERHEAD: usize = 2 + 16;
const POST_CHUNK_OVERHEAD: usize = 16;

fn create_crypto(key: &[u8; Self::KEY_LEN], iv: &[u8; Self::IV_LEN]) -> Self {
let mut subkey = [0u8; Self::KEY_LEN];
Hkdf::<Sha1>::new(Some(iv), key)
  .expand(b"ss-subkey", &mut subkey)
  .unwrap();

Self {
  inner: Inner::new_from_slice(&subkey).unwrap(),
  nonce: Default::default(),
}
}

上面的是一个具体的函数，并没有&self参数 ，所以泛型结构体的方法实现会是一个关联函数， 用大的Self。
pub struct RustCryptoAead<Inner: AeadCore, const SALT_LEN: usize> {
    inner: Inner,
    nonce: GenericArray<u8, Inner::NonceSize>,
}
这个是编译器单态化生成的代码，实际上不需要手动单态化
pub struct RustCryptoAead<Aes128Gcm, const SALT_LEN: usize> {
    inner: Aes128Gcm,
    nonce: GenericArray<u8, U12>, // AES-GCM 使用12字节的 nonce
}

泛型结构体的方法的实现，注意这里有&self,
impl<Inner, const SALT_LEN: usize> RustCryptoAead<Inner, SALT_LEN>
where
    Inner: AeadCore + NewAead,
{
    pub fn encrypt(&mut self, plaintext: &[u8]) -> Vec<u8> {
        // 加密逻辑
    }
}
注意没有&self，使用关联函数



```rust
impl<Inner: AeadCore, const SALT_LEN: usize> RustCryptoAead<Inner, SALT_LEN> {
    fn create_crypto(key: &[u8; Self::KEY_LEN], iv: &[u8; Self::IV_LEN]) -> Self {
        // 实现...
    }
}
```

7. 调用时：

```rust
let aead = RustCryptoAead::<Aes128Gcm, 16>::create_crypto(&key, &iv);
```
