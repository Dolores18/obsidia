。在Rust中,栈上的数据确实与堆上的数据在所有权处理上有所不同,但并不完全 不涉及所有权转移。让我来详细解释一下:

1. 栈上数据的特点:
   - 大小固定
   - 生命周期与作用域绑定
   - 通常是基本类型或小型结构体

2. 栈上数据的所有权:
   - 栈上数据确实有所有权,但通常是通过复制(Copy)而不是移动(Move)来传递
   - 实现了Copy trait的类型在赋值或传参时会自动复制,而不是转移所有权

3. 栈上数据的所有权转移:
   - 对于没有实现Copy trait的自定义类型,即使存储在栈上,在赋值或传参时也会发生所有权转移
   - 这种情况下,原变量将不再可用,所有权被转移到新变量

4. 示例:

```rust
// 基本类型,存储在栈上,实现了Copy
let x = 5;
let y = x; // x被复制,而不是移动

// 自定义类型,存储在栈上,但没有实现Copy
struct Point { x: i32, y: i32 }
let p1 = Point { x: 0, y: 0 };
let p2 = p1; // p1的所有权被移动到p2,p1不再可用

要实现自定义类型的copy，可以通过宏来实现。


```rust
#[derive(Copy, Clone)]
struct Point { x: i32, y: i32 }
```

这样,Point就会像基本类型一样进行复制而不是移动。
