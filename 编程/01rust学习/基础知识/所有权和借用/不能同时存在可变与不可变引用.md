```rust

//代码示例
fn change_str(p:&mut String) {
p.push_str("_test")
}

fn main() {
let mut s = String::from("hello");
let x = &mut s;
change_str(x);
let y = &*x;
assert_eq!(x, y);
println!("{}--{}", x, y);
}

这段代码解释一下，明明现在x已经发生了变化的可变引用，为什么y是新的引用，如果下面这样为什么会报错
fn change_str(p:&mut String) {
p.push_str("_test")
}

fn main() {
let mut s = String::from("hello");
let x = &mut s;
let y = &*x;
change_str(x);

assert_eq!(x, y);
println!("{}--{}", x, y);
}
```

知识点：
在 Rust 中,当存在一个不可变引用时,不允许同时存在可变引用。这是为了防止数据竞争。因此,在创建 `y` 之后,`x` 就不能被用作可变引用了。这就是为什么 `change_str(x)` 会导致编译错误。
