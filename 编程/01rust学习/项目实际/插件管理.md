---
创建时间: 星期六, 8月 24日 2024, 2:13 下午
最近修改: 
---
```rust
use std::sync::{Arc, Weak, Mutex};
use std::io::{Read, Write, Result};
use std::net::TcpStream;

trait StreamProcessor: Send + Sync {
    fn process_read(&self, buf: &mut [u8], inner: &mut dyn Read) -> Result<usize>;
    fn process_write(&self, buf: &[u8], inner: &mut dyn Write) -> Result<usize>;
    fn name(&self) -> &str;
}

struct StreamManager {
    base_stream: Arc<Mutex<dyn Read + Write + Send + Sync>>,
    processors: Arc<Mutex<Vec<Arc<dyn StreamProcessor>>>>,
}

impl StreamManager {
    fn new(stream: impl Read + Write + Send + Sync + 'static) -> Arc<Self> {
        Arc::new(StreamManager {
            base_stream: Arc::new(Mutex::new(stream)),
            processors: Arc::new(Mutex::new(Vec::new())),
        })
    }

    fn add_processor(&self, processor: Arc<dyn StreamProcessor>) {
        self.processors.lock().unwrap().push(processor);
    }

    fn remove_processor(&self, name: &str) {
        self.processors.lock().unwrap().retain(|p| p.name() != name);
    }

    fn get_processed_stream(&self) -> ProcessedStream {
        ProcessedStream {
            inner: Arc::clone(&self.base_stream),
            processors: Arc::downgrade(&self.processors),
        }
    }
}

struct ProcessedStream {
    inner: Arc<Mutex<dyn Read + Write + Send + Sync>>,
    processors: Weak<Mutex<Vec<Arc<dyn StreamProcessor>>>>,
}

impl Read for ProcessedStream {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
        let mut inner = self.inner.lock().unwrap();
        let mut temp_buf = vec![0; buf.len()];
        let mut read_size = inner.read(&mut temp_buf)?;

        if let Some(processors) = self.processors.upgrade() {
            for processor in processors.lock().unwrap().iter() {
                read_size = processor.process_read(&mut temp_buf[..read_size], &mut *inner)?;
            }
        }

        buf[..read_size].copy_from_slice(&temp_buf[..read_size]);
        Ok(read_size)
    }
}

impl Write for ProcessedStream {
    fn write(&mut self, buf: &[u8]) -> Result<usize> {
        let mut inner = self.inner.lock().unwrap();
        let mut temp_buf = buf.to_vec();
        let mut write_size = buf.len();

        if let Some(processors) = self.processors.upgrade() {
            for processor in processors.lock().unwrap().iter() {
                write_size = processor.process_write(&temp_buf[..write_size], &mut *inner)?;
            }
        }

        inner.write(&temp_buf[..write_size])
    }

    fn flush(&mut self) -> Result<()> {
        self.inner.lock().unwrap().flush()
    }
}

// 示例处理器实现（略）

fn main() -> std::io::Result<()> {
    let tcp_stream = TcpStream::connect("example.com:80")?;
    let manager = StreamManager::new(tcp_stream);

    // 添加处理器
    manager.add_processor(Arc::new(AuthProcessor {
        auth_token: "my_secret_token".to_string(),
    }));
    manager.add_processor(Arc::new(ShapingProcessor {
        max_bytes: 1024,
    }));

    // 获取处理后的流
    let mut processed_stream = manager.get_processed_stream();

    // 使用处理后的流
    processed_stream.write(b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")?;

    // 动态移除处理器
    manager.remove_processor("Auth");

    // 继续使用处理后的流
    let mut response = [0; 2048];
    let bytes_read = processed_stream.read(&mut response)?;

    println!("Response: {:?}", String::from_utf8_lossy(&response[..bytes_read]));

    Ok(())
}
