##闭包可以用来简化代码
如果一个函数内部需要多次调用一个外部函数，那么闭包的好处就是可以简化代码，而且利于后续的重构代码。

##FnOnece 只能调用一次的闭包
```rust
//前面是为闭包做了约束，要求传入的是一个闭包，并且只能调用一次，FnOnce
fn fn_once<F>(func: F)
where
    F: FnOnce(usize) -> bool,
{
    println!("{}", func(3));
    println!("{}", func(4));
}

fn main() {
    let x = vec![1, 2, 3];
    fn_once(|z|{z == x.len()})
}
```
##结构体中的闭包
```rust
use std::collections::HashMap;

struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    query: T,
    value: HashMap<u32, u32>,
}

impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(query: T) -> Cacher<T> {
        Cacher {
            query,
            value: HashMap::new(),
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value.get(&arg) {
            Some(&v) => v,
            None => {
                let v = (self.query)(arg);
                self.value.insert(arg, v);
                v
            }
        }
    }
}

fn main() {
    // 创建一个耗时的计算函数
    let expensive_calculation = |num: u32| {
        println!("计算中...");
        std::thread::sleep(std::time::Duration::from_secs(2));
        num * 2
    };

    // 创建 Cacher 实例
    let mut cacher = Cacher::new(expensive_calculation);

    // 第一次调用，会执行计算
    println!("First call: {}", cacher.value(10));

    // 第二次调用相同的参数，会直接返回缓存的结果
    println!("Second call: {}", cacher.value(10));

    // 使用不同的参数调用，会再次执行计算
    println!("Third call with different arg: {}", cacher.value(20));

    // 再次使用第一个参数调用，会返回缓存的结果
    println!("Fourth call with first arg: {}", cacher.value(10));
}
```
